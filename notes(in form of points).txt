[1.] 2**n == 2^n

[2.] reverse string string[::-1]

[3.] len(intVar) not happens
do either len(str(intVar))


[4.] //array of Arrays
numbersList = []
listofNumbers = [1,2,3]
secondListofNumbers = [4,5,6]
numbersList.append(listofNumbers)
numbersList.append(secondListofNumbers)
for number in numbersList:
    print(number) 


[5.] for non duplicate numbers do
sort the number array then chk chk
 if index > 0 and number[index]==number[index-1]:
	continue


[6.]
two pointer theorem
two pointers within array starts from same place or oppostie
example l______________r
while l>r:
  l++
  r--

[7.]
int to its equivalent char in ascii
charInASCIIatPOSi = chr(i)

or

i = ord(charInASCIIatPOSi)

[8.]
upper to lower case
character= chr(ord(character)+32)

lower to uppercase
character= chr(ord(character)-32)

[9.]
sort interval array on basis on 1st elem.(entry point)
intervals.sort(key = lambda x: x[0])

or

def f(x):
  return f[0]

intervals  = sorted(intervals,key=f)


[10.]
STACKS LIFO

push(val)  -> add val on top of stack
pop() --> deletes and returns the topmost val
top()  --> returns the top of stack w/o deleting

QUEUES  FIFO
frontend removal
rearend adding

IMPLEMENTATION IN REGULAR WAY
push(val) <==> arr.appen(val)
pop() <==> arr.pop()
top() <==> arr[-1]

QUEUES
push(val)  <==> arr.append(val)
pop()  <==> pop(0)  --> remove from frontend


[11.]
Return index of num in arr
num = 4
arr = [5,6,2,4,0]
arr.index(4) ---> 3

[12.]
Queue operations

from collections import deque

a = deque([1,2,3,4])
__________________
a.popleft()       |
a.appendleft()    |
__________________|

[13.]
To create hashmap of number of occurence of aplhabets in string

count = [0]*26   all occurences set to 0 

for i in range(len(string)):
  count[ord(string[i])-65] += 1
          ##ascii 
             ##e.g., for B count[2]
                     for C count[3]

[14.]
Biggest binary of 4 bits
0b1111

{} int to binary --> bin(88)  returns binary
{} binary to int -- > int('0b10011000',2) returns 88

>>> a=int('01100000', 2)
>>> b=int('00100110', 2)
>>> bin(a & b)
'0b100000'
>>> bin(a | b)
'0b1100110'
>>> bin(a ^ b)
'0b1000110'

[15.]
abc     base = b
magnitude = c*b**0 + b*b**1 + a*b**2


[16.]
left shift 
    num
100101100 << 1 : 001011000 <===> num*2 in decimal

for right shift --> newNum = num/2 (in decimal)

[17.]
Sum Of two decimal Numbers

1 + 1 = 2 = 1 0
0+1 or 1+0 =  1
0 + 0     =   0

we use....
sum = a^b
carry = a&b
ANSWER = sum + a&b<<1

def getSum(a,b):
 if b==0:return a
 return getSum(a^b, (a&b)<<1)

8 bit number
4 : 00000100
-4 : ~4 not4 : 11111011